
	Addresses are 16 bits at least

	Registers
		16 bit general purpose registers with 8 bit halves and 4-8 SIMD
			A - AX AH AL
			B - BX BH BL
			C - CX CH CL
			D - DX DH DL
		
		16 bit extra registers
			Index I
			Index J
		
		32 bit address registers
			Stack Pointer SP (used by push/pop, call/return)
			Base Pointer BP
		
		Special purpose registers
			Instruction Pointer IP (32 bit)
				not accessed directly
			
			Flags F (16 bit)
				can be pushed/popped
		
		F layout
		|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
		|  F |  E |  D |  C |  B |  A |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
		|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
		| Z3 | O3 | S3 | C3 | Z2 | O2 | S2 | C2 | Z1 | O1 | S1 | C1 | Z0 | O0 | S0 | C0 | packed 4s
		|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
		| Z1 | O1 | S1 | C1 |                   | Z0 | O0 | S0 | C0 |                   | packed 8s
		|----|----|----|----|-------------------|----|----|----|----|-------------------|
		|  Z |  O |  S |  C |                                                           | 8/16 bit, conditions
		|----|----|----|----|-----------------------------------------------------------|
		
		
		
		
		rim bytes
		|---|---|---|---|---|---|---|---|
		| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
		|---|---|---|---|---|---|---|---|
		| s | r |     d reg |     s rim |
		|---|---|-----------|-----------|
		
		r rim type:	0 = register-register, 1 = register-immediate/register-memory
		
		size	normal	wide	packed
		0		16 bit	32 bit	2x8
		1		8 bit	16 bit	4x4
		
		bio bytes
		|---|---|---|---|---|---|---|---|
		| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
		|---|---|---|---|---|---|---|---|
		| scale | pair base |     index |
		|-------|-----------|-----------|
		
		addr = base + (index * scale) + offset
		
		if there is an index, scale is the number of left-shifts applied to the index, and the offset is 32-bit
		if there is no index, (scale + 1) is the number of bytes of the offset
		
		value	reg			immediate/memory
				16  8
		000		A	AL		immediate value source
		001		B	BL		immediate address source
		010		C	CL		base + index source
		011		D	DL		base + index + offset source
		100		I	AH		???
		101		J	BH		immediate address destination
		110		BP	CH		base + index destination
		111		SP	DH		base + index + offset destination
		
				pair	index
		000		D:A		A
		001		A:B		B
		010		B:C		C
		011		C:D		D
		100		J:I		I
		101		I:J		J
		110		BP		BP
		111		SP/none	none
		
		As an argument, pair 111 is always SP
		As a base, pair 111 is SP if the index is none (111), and is none otherwise.
		[SP + offset] is a valid address, while [base + (scale * SP) + offset] is not.
		
		Destinations 32-bit results use their corresponding pairs. Sources for BP and SP use 2x width
		i.e. size bit 0 = pair, 1 = 16. Any source too small for its destination is sign-extended
		unless the instruction MOVZ is used	
		
	Aliases
		CLC 		-> CMP A, A
		MOV r1, i0	-> XOR r1, r1
		ICC r1		-> ADC r1, i0
		DCC r1		-> SBC r1, i0
		
	Conditions
		MP always
		
		C carry
		NC not carry
		
		S sign
		NS not sign
		
		O overflow
		NO not overflow
		
		E equal
		NE not equal
		
		G greater
		GE greater or equal
		
		L less
		LE less or equal
		
		Z zero = E equal
		NZ not zero = NE not equal
		