
	NotSoTiny ISA

Registers
	General Purpose Registers
	32-bit	16-bit	8-bit
					Upper	Lower
	D:A		A		AH		AL
			B		BH		BL
	B:C		C		CH		CL
			D		DH		DL
	J:I		I
			J
	L:K		K
			L
	
	Pointer Registers
	32-bit
	XP		General-purpose pointer
	YP		General-purpose pointer
	BP		Base Pointer
	SP		Stack Pointer
	IP		Instruction Pointer
	
	Special Purpose Registers
	16-bit
	F		Arithmetic Flags
	
	Protected Registers
	32-bit
	ISP		Interrupt Stack Pointer
	
	16-bit
	PF		Processor Flags
	
	F layout
	|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
	|  F |  E |  D |  C |  B |  A |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
	|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
	| Z3 | O3 | S3 | C3 | Z2 | O2 | S2 | C2 | Z1 | O1 | S1 | C1 | Z0 | O0 | S0 | C0 | packed 4s
	|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
	|                   | Z1 | O1 | S1 | C1 |                   | Z0 | O0 | S0 | C0 | packed 8s
	|-------------------|----|----|----|----|-------------------|----|----|----|----|
	|                                                           | Z0 | O0 | S0 | C0 | non-packed
	|-----------------------------------------------------------|----|----|----|----|
	Field	Description
	Z		Zero
	O		Overflow
	S		Sign
	C		Carry
	
	PF layout
	|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
	|  F |  E |  D |  C |  B |  A |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
	|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
	|                                                                | II | PV | IE |
	|----------------------------------------------------------------|----|----|----|
	Field					Startup		Interrupt	Description
	IE: Interrupt Enable	0			0			If 1, maskable interrupts are allowed. If 0, maskable interrupts are ignored.
	PV:	Privilege Level		1			1			If 1, privileged. If 0, unprivileged.
	II: In Interrupt		1			1			Set to 1 when an interrupt is fired (INT executed)



Instruction Encoding
	Field		Size (bytes)	Required?
	Opcode		1				Required
	RIM			1				Optional
	BIO			1				Optional
	Immediate	1, 2, 3, 4		Optional
	EI8			1				Optional
	
	RIM Encoding (See "rim reference.txt")
	|---|---|---|---|---|---|---|---|
	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|
	| s | r |       reg |       rim |
	|---|---|-----------|-----------|
	
	'r' field (Register)
	0	'rim' field specifies a register
	1	'rim' field specifies memory
	
	's' field (Size)
		normal	wide	packed	protected
	0	16-bit	32-bit	2x8-bit	p32
	1	8-bit	16-bit	4x4-bit	p16
	
	'reg' and 'rim' fields
	value	register			memory
			8	16	32	p16	p32
	000		AL	A	D:A	PF	ISP	immediate value source
	001		BL	B	B:C			immediate address source
	010		CL	C	J:I			base + index source
	011		DL	D	L:K			base + index + offset source
	100		AH	I	XP			invalid
	101		BH	J	YP			immediate address destination
	110		CH	K	BP			base + index destination
	111		DH	L	SP			base + index + offset destination
	
	The 'reg' field always specifies a register.
	If the 'rim' field specifies a register, the 'reg' field specifiese the destination and the
	'rim' field specifies the source.
	If the 'rim' field specifies memory, the 'reg' field specifies the source or destination not
	specified by the 'rim' field.
	"base + index" and "base + index + offset" memory locations are specified by the BIO byte and
	Immediate bytes.
	
	BIO Encoding (See "bio reference.txt")
	|---|---|---|---|---|---|---|---|
	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|
	| scale | pair base | r16 index |
	|-------|-----------|-----------|
	
	value	r16	pair	Offset Size					IP-relative Index
	000		A	D:A		Normal base, 1-byte offset	None
	001		B	B:C		Normal base, 2-byte offset	None
	010		C	J:I		Normal base, 3-byte offset	None
	011		D	L:K		Normal base, 4-byte offset	None
	100		I	XP		IP-relative, 1-byte offset	I
	101		J	YP		IP-relative, 2-byte offset	J
	110		K	BP		IP-relative, 3-byte offset	K
	111		L	SP/none	IP-relative, 4-byte offset	L
	
	value	scale
	00		0
	01		1
	10		2
	11		4
	
	The address of a memory location specified by the BIO byte and Immediate bytes is
		base + (zeroext(index) * scale) + signext(offset)
	If scale = 0, the 'index' field specifies the size of the offset immediate and whether to use
	IP-relative addressing.
	In IP-relative addressing, IP is used as the base, and the 'base' field is used to specify an
	index.
	The IP register points to the first byte of the subsequent instruction.
	If scale = 0, 'base' 111 is SP.
	If scale != 0, 'base' 111 is none.



Packed/Conditional Notation
	Mnemonics take the form [P]<mnemonic>[4/8][condition]
	
	Packed operations are prefixed with P and immediately suffixed with 4 (4x4-bit) or 8 (2x8-bit).
	Conditions form the final suffix as <base condition>[packing]
	
	Excepting shortcut opcodes, conditions are specified by the EI8 field as follows:
		Bits 3:0 specify the base condition:
			value	mnemonic	flag logic
			0000	n/a			unconditional
			0001	n/a			unconditional
			0010	C			C
			0011	NC			!C
			0100	S			S
			0101	NS			!S
			0110	O			O
			0111	NO			!O
			1000	Z			Z
			1001	NZ			!Z
			1010	A			C NOR Z
			1011	BE			C OR Z
			1100	G			!Z ABD (S XNOR O)
			1101	GE			S XNOR O
			1110	L			S XOR O
			1111	LE			Z OR (S XOR O)
		Bits 6:4 specify condition packing:
			value	suffix		description
			000					non-packed
			001					non-packed
			010					non-packed
			011					non-packed
			100		.A8			any packed-8 met
			101		.E8			all packed-8 met
			110		.A4			any packed-4 met
			111 	.E4			all packed-4 met
		
	Examples
		JNZ			Jump if not zero
		JL.E8		Jump if less for each 8
		JGE.A4		Jump if greater than for any 4
		PCMOV4C		Packed conditional move of 4s if carry set



Exceptions
	A processor reset branches to the reset vector (0x00)
	Reading or writing memory that does not exist raises a memory error (0x08)
	Division by zero raises a division error (0x0D)
	Invalid opcodes and RIM bytes (no invalid BIO bytes exist) raise a decoding error (0x0F)
	Reading or writing protected registers while unprivileged raises a general protection fault (0x10)
		INT may write to protected registers for select vectors
	Reading or writing protected memory while unprivileged raises a memory protection fault (0x11)



Other Notes
	Calling Convention
		A, B, C, D are caller-saved
		I, J, K, L, XP, YP, BP, SP are callee-saved
		Return values are placed in B:C:D:A
		The rightmost argument is pushed first
		Arguments are not required to be aligned



Instruction Descriptions
	When sources and destinations are described, they may be prefixed as follows:
		wide	uses wide encoding
		high	uses high half of wide
		low		uses low half of wide



	NOP
		No-Operation
	
	MOV
		destination <- source
	
	MOVW
		wide destination <- wide source
	
	MOVS
		wide destination <- signext(source)
	
	MOVZ
		wide destination <- zeroext(source)
	
	CMOVcc
		If condition met:
			destination <- source
		
		The source is always read.
		Has packed variant.
		When packed, the destination is always written. When not packed, the destination is only
		written if the condition is met.
		When packed, conditions are applied per element and are always non-packed.
	
	XCHG
		destination <- source
		source <- destination
	
	XCHGW
		wide destination <- wide source
		wide source <- wide destination
	
	PUSH
		[SP - size]	<- source
		SP			<- SP - size
	
	PUSHW
		[SP - size]	<- wide source
		SP			<- SP - size
	
	RPUSH
		[32-bit register destination - size]	<- source
		32-bit register destination				<- 32-bit register destination - size
		
		Raises a decoding error if destination is not a register.
		Destination uses the 32-bit register specified by the field regardless of 's'.
	
	RPUSHW
		[32-bit register destination - size]	<- wide source
		32-bit register destination				<- 32-bit register destination - size
		
		Raises a decoding error if destination is not a register.
		Destination uses the 32-bit register specified by the field regardless of 's'.
	
	POP
		destination	<- [SP]
		SP			<- SP + size
	
	POPW
		wide destination	<- [SP]
		SP					<- SP + size
	
	RPOP
		destination				<- [32-bit register source]
		32-bit register source	<- 32-bit register source + size
		
		Raises a decoding error if source is not a register.
		Source uses the 32-bit register specified by the field regardless of 's'.
	
	RPOPW
		wide destination			<- [32-bit register source]
		32-bit register source		<- 32-bit register destination
		
		Raises a decoding error if the source is not a register.
		Source uses the 32-bit register specified by the field regardless of 's'.
	
	PUSHA
		[SP - 4]	<- D:A
		[SP - 8]	<- B:C
		[SP - 12]	<- J:I
		[SP - 16]	<- L:K
		SP			<- SP - 16
	
	POPA
		D:A	<- [SP + 12]
		B:C	<- [SP + 8]
		J:I	<- [SP + 4]
		L:K	<- [SP + 0]
		SP	<- SP + 16
	
	LEA
		32-bit register destination	<- source address
		
		Raises a decoding error if destination is not a register or source is not memory.
		Destination uses the 32-bit register specified by the field regardless of 's'.
	
	HWI
		Hardware Instruction
		Reserved opcode for model-specific instructions. Use of the EI8 field as a second opcode is
		encouraged.
	
	JMP
		IP	<- IP + source
	
	JMPA
		IP	<- 32-bit source
		
		Source is 32-bit regardless of 's'.
	
	Jcc
		If condition met:
			IP <- IP + source
	
	CALL
		[SP - 4]	<- IP
		SP			<- SP - 4
		IP			<- IP + source
	
	CALLA
		[SP - 4]	<- IP
		SP			<- SP - 4
		IP			<- 32-bit source
		
		Source is 32-bit regardless of 's'.
	
	RET
		IP	<- [SP]
		SP	<- SP + 4
	
	INT
		If II = 1
			[SP - 4]	<- IP
			[SP - 8]	<- BP
			[SP - 12]	<- SP
			[SP - 14]	<- F
			[SP - 16]	<- PF
			BP			<- vector-specific value
			SP			<- SP - 16
			IP			<- [source * 4]
			F			<- vector-specific value
			PF			<- IE = 0, PV = 1, II = 1
			
		If II = 0
			[ISP - 4]	<- IP
			[ISP - 8]	<- BP
			[ISP - 12]	<- SP
			[ISP - 14]	<- F
			[ISP - 16]	<- PF
			BP			<- vector-specific value
			SP			<- ISP - 16
			IP			<- [source * 4]
			F			<- vector-specific value
			PF			<- IE = 0, PV = 1, II = 1
	
	IRET
		IP	<- [SP + 12]
		BP	<- [SP + 8]
		SP	<- [SP + 4]
		F	<- [SP + 2]
		PF	<- [SP + 0]
	
	HLT
		Halts execution until an external interrupt.
		Raises a general protection fault if unprivileged.
	
	CMP
		F	<- flags for destination - source
		
		Has packed variant.
	
	CMPW
		F	<- flags for wide destination - wide source
	
	ADD
		destination	<- destination + source
		F			<- flags
		
		Has packed variant.
	
	ADDW
		wide destination	<- wide destination + wide source
		F					<- flags
	
	ADC
		destination	<- destination + source + C
		F			<- flags
		
		Has packed variant.
	
	ADCW
		wide destination	<- wide destination + wide source + C
		F					<- flags
	
	AADJ
		destination	<- decimal-adjust-addition destination
		F			<- flags
		
		Adjust destination value such that the instruction sequence
			PADD4 <a>, <b>
			AADJ <a>
		performs the addition of a 4-BCD-digit word.
		An instruction sequence of the form
			PADD4 <a>, <b>
			AADJ <a>
			PADC4 <c>, <d>
			AADJ <c>
			(etc)
		will perform addition for longer BCD words.
	
	SUB
		destination	<- destination + source
		F			<- flags
		
		Has packed variant.
	
	SUBW
		wide destination	<- wide destination + wide source
		F					<- flags
	
	SBB
		destination	<- destination - source - C
		F			<- flags
		
		Has packed variant.
	
	SBBW
		wide destination	<- wide destination - wide source - C
		F					<- flags
	
	SADJ
		destination	<- decimal-adjust-subtraction destination
		F			<- flags
		
		Adjust destination value such that the instruction sequence
			PSUB4 <a>, <b>
			SADJ <a>
		performs the subtraction of a 4-BCD-digit word.
		An instruction sequence of the form
			PSUB4 <a>, <b>
			SADJ <a>
			PSBB4 <c>, <d>
			SADJ <c>
			(etc)
		will perform subtraction for longer BCD words
	
	INC
		destination	<- destination + 1
		F			<- flags
		
		Has packed variant.
	
	INCW
		wide destination	<- wide destination + 1
		F					<- flags
	
	ICC
		destination	<- destination + C
		F			<- flags
		
		Has packed variant.
	
	ICCW
		wide destination	<- wide destination + C
		F					<- flags
	
	DEC
		destination	<- destination - 1
		F			<- flags
		
		Has packed variant.
	
	DECW
		wide destination	<- wide destination - 1
		F					<- flags
	
	DCC
		destination	<- destination - C
		F			<- flags
		
		Has packed variant.
	
	DCCW
		wide destination	<- wide destination - C
		F					<- flags
	
	MUL
		destination	<- destination * source
		F			<- flags
		
		Has packed variant.
	
	MULH
		wide destination	<- low destination unsigned* source
		F					<- flags
		
		Has packed variant.
		When packed, result is arranged as a single packed value (4x4 -> 4x8, 2x8 -> 2x16)
	
	MULSH
		wide destination	<- low destination unsigned* source
		F					<- flags
		
		Has packed variant.
		When packed, result is arranged as a single packed value (4x4 -> 4x8, 2x8 -> 2x16)
	
	DIV
		destination	<- destination unsigned/ source
		F			<- flags
		
		Truncates towards zero.
		Sets the carry and overflow flags if the quotient is too large for the destination.
		Has packed variant.
	
	DIVS
		destination	<- destination signed/ source
		F			<- flags
		
		Truncates towards zero.
		Sets the carry and overflow flags if the quotient is too large for the destination.
		Has packed variant.
	
	DIVM
		high destination	<- wide destination unsigned% source
		low destination		<- wide destination unsigned/ source
		F					<- flags
		
		Truncates towards zero.
		Sets the carry and overflow flags if the quotient is too large for the destination.
		Sets the zero flag according to both the quotient and remainder.
		Sets the sign flag according to the quotient.
		Has packed variant.
		When packed, a packed quotient and packed result are each produced.
	
	DIVMS
		high destination	<- wide destination signed% source
		low destination		<- wide destination signed/ source
		F					<- flags
		
		Truncates towards zero.
		Sets the carry and overflow flags if the quotient is too large for the destination.
		Sets the zero flag according to both the quotient and remainder.
		Sets the sign flag according to the quotient.
		Has packed variant.
		When packed, a packed quotient and packed result are each produced.
	
	TST
		F	<- flags for destination & source
		
		Has packed variant.
	
	AND
		destination	<- destination & source
		F			<- flags
		
		Has packed variant.
	
	OR
		destination	<- destination | source
		F			<- flags
		
		Has packed variant.
	
	XOR
		destination	<- destination ^ source
		F			<- flags
		
		Has packed variant.
	
	NOT
		destination	<- !destination
		F			<- flags
		
		Has packed variant.
	
	NEG
		destination	<- 0 - destination
		F			<- flags
		
		Has packed variant.
	
	SHL
		destination	<- destination << (source % bits)
		F			<- flags
		
		Sets carry to the last bit shifted out.
	
	SHR
		destination	<- destination logical>> (source % bits)
		F			<- flags
		
		Sets carry to the last bit shifted out.
	
	SAR
		destination	<- destination arithmetic>> (source % bits)
		F			<- flags
		
		Sets carry to the last bit shifted out.
	
	ROL
		destination	<- destination rotated left source bits
		F			<- flags
		
	RCL
		destination <- destination rotated left through carry source bits
		F			<- flags
	
	RCR
		destination	<- destination rotated right through carry source bits
		F			<- flags
